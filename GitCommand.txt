git init
git status
git add
git add .	 добавить все файлы из текущей директории введите
git add --all	 добавить файлы из текущей директории и из всех поддиректориев
git commit -m "Description"
git log Просмотр истории коммитов
	-p, который показывает дельту (разницу/diff), привнесенную каждым коммитом. 
	Вы также можете использовать -2, что ограничит вывод до 2-х последних записей:
	git log -p -2

git remote add NAME "PATH" сылка на удаленный репозиторий

git remote
git remote -v  посмотреть связи
git remote show NAME

git fetch NAME получить инфу из удаленного репозитория которой еще нет в локальном,
		например ссылки на ветки, которых у нас еще нет. Внимание! 
		Команда git fetch никак не изменяет наши файлы!

git checkout --track REMOTENAME/master 	связать нашу ветку master и ветку master удаленного
					репозитория




Работа с гитхаб

1 	Создаем репозиторий. При создании просим сразу создать в нём файл
	README (это упростит нам дальнейшую работу)
2	Запоминаем адрес нашего репозитория (clone URL)
3	Клонируем этот репозиторий к себе на компьютер:
	git clone CLONE_URL PROJECT_FOLDER
В результате мы получаем у себя репозиторий, являющийся точной копией
удалённого репозитория. Более того – они связаны невидимой связью и мы этим
воспользуемся!

git pull  не просто «достаёт» изменения, но и пытается применить изменения с
	  удаленного репозитория к нашему (влить удаленную ветку в локальную)
git push  отправляет наши наборы изменений на удалённый репозиторий


Работа с ветками

git branch testing  	создается новая ветка testing
git branch -v 		какие ветки существуют
git checkout testing	Эта команда передвинет HEAD на ветку testing
git checkout -b testing создает и перемещает на ветку testing

git checkout master
git merge testing  	слияние двух веток (когда ветки master и testing на одной линии)
			возьми все изменения из ветки hotfix которых в master нету
			и попытайтесь к master применить
			Что вливаем стоит в команде merge, куда вливаем должна быть текущая ветка

git branch -d hotfix	удалить ветку hotfix


git rebase master	копия текущий ветки в ветку мастер


git rebase -i HEAD~4
Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target).
Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
После открытия окна интерактивного rebase есть три варианта для каждого коммита:
	-Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе 
	(у нас в окошке строку с коммитом можно перенести просто мышкой).
	-Можно "выкинуть" коммит из ребейза. Для этого есть pick - 
	переключение его означает, что нужно выкинуть коммит.
	-Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, 
	но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.


Esc :w			записать изменения
Esc :q			выход из редактора	



Решаем конфликты

git status	покажет файлы с конфликтами
		В них вы найдете метки у конфликтых мест

Чтобы «решить конфликт», вы должны оставить нужный вам 
вариант или переписать проблемное место заново

Затем не забудьте git add ...
конфликтного файла – проиндексировать его


И потом, когда все конфликты решены, git commit ...

Решение конфликтов – это та часть «Дао Git», в которой я рекомендую пользоваться
графическими инструментами. Меньше возможности ошибиться!





ТЕГИ – это метки, которыми можно пометить коммит.

git tag 1.0		Эта команда помечает текущий коммит легкой меткой 1.0
git tag			выведет список всех меток в вашем репозитории
git tag -l '1.*'	Список меток по маске
git show 1.0		Просмотр информации о заданной метке
git tag -d 1.0		Удаление метки
git tag v1 C1		Создадим тег на C1, который будет нашей версией 1
	

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, 
над которым мы в данным момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. 
Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.
Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, 
статус ветки bugFix меняется и это изменение видно через HEAD.
Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту.
Применяем команду git checkout 


Относительные ссылки
Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит.
Оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
Так что master^ означает "первый предок ветки master". master^^ означает предок предка ветки master
Можно также использовать HEAD как относительную ссылку. Это значит можем путешествовать по коммитам при помощи HEAD^

~ К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти.

Можно напрямую прикрепить ветку к коммиту при помощи опции -f
git branch -f master HEAD~3  	Переместит (принудительно) ветку master на три родителя назад от HEAD.



Отмена изменений в Git

Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert.

Git Reset
git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. 
Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
git reset HEAD~1


Git Revert
Reset отлично работает на локальных ветках, в локальных репозиториях. 
Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.
Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.
После revert можно сделать push и поделиться изменениями с остальными.
git revert HEAD


git cherry-pick <Commit1> <Commit2> <...>
Это очень простой и прямолинейный способ сказать, 
что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD).



git describe <ref>	показывает, как далеко текущее состоянии от ближайшего тега.
			Git describe помогает сориентироваться после отката на много коммитов по истории изменений. 
Где ref — это что-либо, что указывает на конкретный коммит. 
Если не указать ref, то git будет считать, что указано текущее положение (HEAD).
Вывод команды выглядит примерно так:

<tag>_<numCommits>_g<hash>	Где tag – это ближайший тег в истории изменений, 
				numCommits – это на сколько далеко мы от этого тега, 
				а hash – это хеш коммита, который описывается.





















