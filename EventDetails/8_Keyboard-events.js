/*Клавиатура: keyup, keydown, keypress
События keydown/keyup происходят при нажатии/отпускании клавиши и позволяют получить её скан-код в свойстве keyCode.
Скан-код клавиши одинаков в любой раскладке и в любом регистре. Например, клавиша z может означать символ "z",
"Z" или "я", "Я" в русской раскладке, но её скан-код будет всегда одинаков: 90.
Скан-коды
Для буквенно-цифровых клавиш есть очень простое правило: скан-код будет равен коду соответствующей заглавной английской буквы/цифры.
Например, при нажатии клавиши S (не важно, каков регистр и раскладка) её скан-код будет равен "S".charCodeAt(0).

Когда-то в этих кодах была масса кросс-браузерных несовместимостей. Сейчас всё проще – таблицы кодов в различных браузерах почти полностью совпадают. Но некоторые несовместимости, всё же, остались. Вы можете увидеть их в таблице ниже.

Клавиша		Firefox		Остальные браузеры
;			59			186
=			107			187
-			109			189*/


/*Событие keypress
Событие keypress возникает сразу после keydown, если нажата символьная клавиша, т.е. нажатие приводит к 
появлению символа. Любые буквы, цифры генерируют keypress. Управляющие клавиши, 
такие как Ctrl, Shift, F1, F2… – keypress не генерируют.
Событие keypress позволяет получить код символа. В отличие от скан-кода, он специфичен
именно для символа и различен для "z" и "я".
Код символа хранится в свойствах: charCode и which. Здесь скрывается целое «гнездо» кросс-браузерных несовместимостей, разбираться с которыми нет никакого смысла – запомнить сложно, а на практике нужна лишь одна «правильная» функция, позволяющая получить код везде.

Получение символа в keypress
Кросс-браузерная функция для получения символа из события keypress:*/
// event.type должен быть keypress
function getChar(event) {
  if (event.which == null) { // IE
    if (event.keyCode < 32) return null; // спец. символ
    return String.fromCharCode(event.keyCode)
  }

  if (event.which != 0 && event.charCode != 0) { // все кроме IE
    if (event.which < 32) return null; // спец. символ
    return String.fromCharCode(event.which); // остальные
  }

  return null; // спец. символ
}

/*Для общей информации – вот основные браузерные особенности, учтённые в getChar(event):
	1_Во всех браузерах, кроме IE, у события keypress есть свойство charCode, которое содержит код символа.
	2_Браузер IE для keypress не устанавливает charCode, а вместо этого он записывает код символа в keyCode
	(в keydown/keyup там хранится скан-код).
	3_Также в функции выше используется проверка if(event.which!=0), а не более короткая if(event.which).
	Это не случайно! При event.which=null первое сравнение даст true, а второе – false.*/

/*Неправильный getChar
В сети вы можете найти другую функцию того же назначения:*/
function getChar(event) {  return String.fromCharCode(event.keyCode || event.charCode);}
/*Она работает неверно для многих специальных клавиш, потому что не фильтрует их. Например, она возвращает символ амперсанда "&", когда нажата клавиша „Стрелка Вверх“. Лучше использовать ту, что приведена выше.*/

/*При keydown/keypress значение ещё старое
На момент срабатывания keydown/keypress клавиша ещё не обработана браузером.
Поэтому в обработчике значение input.value – старое, т.е. до ввода. Это можно увидеть в примере ниже. Вводите символы abcd.., а справа будет текущее input.value: abc..
А что, если мы хотим обработать input.value именно после ввода? Самое простое решение – использовать событие keyup, либо запланировать обработчик через setTimeout(..,0).*/

/*Отмена любых действий
Отменять можно не только символ, а любое действие клавиш.

Например:
	При отмене Backspace – символ не удалится.
	При отмене PageDown – страница не прокрутится.
	При отмене Tab – курсор не перейдёт на следующее поле.
Конечно же, есть действия, которые в принципе нельзя отменить, в первую очередь – те, которые происходят на уровне операционной системы. Комбинация Alt+F4 инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.*/

/*Демо: перевод символа в верхний регистр
В примере ниже действие браузера отменяется с помощью return false,
а вместо него в input добавляется значение в верхнем регистре:*/
<input id="only-upper" type="text" size="2"> <script>
  document.getElementById('only-upper').onkeypress = function(e) {
    // спец. сочетание - не обрабатываем
    if (e.ctrlKey || e.altKey || e.metaKey) return;

    var char = getChar(e);

    if (!char) return; // спец. символ - не обрабатываем

    this.value = char.toUpperCase();

    return false;  };</script>

/*Несовместимости
Некоторые несовместимости в порядке срабатывания клавиатурных событий (когда что) ещё существуют.
Стоит иметь в виду три основных категории клавиш, работа с которыми отличается.
Общий вывод можно сделать такой:
Обычные символы работают везде корректно.
CapsLock под MacOS ведёт себя плохо, не стоит ставить на него обработчики вообще.
Для других специальных клавиш и сочетаний с ними следует использовать только keydown.*/

/*Автоповтор
При долгом нажатии клавиши возникает автоповтор. По стандарту, должны генерироваться многократные
события keydown (+keypress), и вдобавок стоять свойство repeat=true у объекта события.
То есть поток событий должен быть такой:
	keydown
	keypress
	keydown
	keypress
	..повторяется, пока клавиша не отжата...
	keyup
Однако в реальности на это полагаться нельзя. На момент написания статьи, под Firefox(Linux)
генерируется и keyup:
	keydown
	keypress
	keyup
	keydown
	keypress
	keyup
	..повторяется, пока клавиша не отжата...
	keyup
…А Chrome под MacOS не генерирует keypress. В общем, «зоопарк».
Полагаться можно только на keydown при каждом автонажатии и keyup по отпусканию клавиши.*/

/*Итого
Ряд рецептов по итогу этой главы:

	1_Для реализации горячих клавиш, включая сочетания – используем keydown. Скан-код будет в keyCode, почти все скан-коды кросс-браузерны, кроме нескольких пунктуационных, перечисленных в таблице выше.
	
	2_Если нужен именно символ – используем keypress. При этом функция getChar позволит получить символ и отфильтровать лишние срабатывания. Гарантированно получать символ можно только при нажатии обычных клавиш, если речь о сочетаниях с модификаторами, то keypress не всегда генерируется.
	
	3_Ловля CapsLock глючит под MacOS. Её можно организовать при помощи проверки navigator.userAgent и navigator.platform, а лучше вообще не трогать эту клавишу.
	
Распространённая ошибка – использовать события клавиатуры для работы с полями ввода в формах.

Это нежелательно. События клавиатуры предназначены именно для работы с клавиатурой. 
Да, их можно использовать для проверки ввода в <input>, но будут недочёты. 
Например, текст может быть вставлен мышкой, при помощи правого клика и меню, без единого нажатия клавиши. 
И как нам помогут события клавиатуры?

Некоторые мобильные устройства также не генерируют keypress/keydown, а сразу вставляют текст в поле.
Обработать ввод на них при помощи клавиатурных событий нельзя.

Далее мы разберём события для элементов форм, которые позволяют работать с вводом в формы правильно.

Их можно использовать как отдельно от событий клавиатуры, так и вместе с ними.*/














