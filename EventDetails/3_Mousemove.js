/*Мышь: движение mouseover/out, mouseenter/leave

События mouseover/mouseout, свойство relatedTarget
Событие mouseover происходит, когда мышь появляется над элементом, а mouseout – когда уходит из него.
При этом мы можем узнать, с какого элемента пришла (или на какой ушла) мышь, 
используя дополнительное свойство объекта события relatedTarget.

Например, в обработчике события mouseover:
	event.target – элемент, на который пришла мышь, то есть на котором возникло событие.
	event.relatedTarget – элемент, с которого пришла мышь.
	
Для mouseout всё наоборот:
	event.target – элемент, с которого ушла мышь, то есть на котором возникло событие.
	event.relatedTarget – элемент, на который перешла мышь.*/
	
/*relatedTarget может быть null
Свойство relatedTarget может быть равно null.
Это вполне нормально и означает, что мышь пришла не с другого элемента, а из-за пределов 
окна (или ушла за окно). Мы обязательно должны иметь в виду такую возможность, 
когда пишем код, который обращается к свойствам event.relatedTarget.*/



/*Частота событий
Событие mousemove срабатывает при передвижении мыши. Но это не значит, 
что каждый пиксель экрана порождает отдельное событие!
События mousemove и mouseover/mouseout срабатывают так часто, насколько это позволяет внутренняя система взаимодействия с мышью браузера.
Это означает, что если посетитель двигает мышью быстро, то DOM-элементы, через которые мышь проходит на большой скорости, могут быть пропущены.

При быстром движении с элемента #FROM до элемента #TO, как изображено на картинке выше – промежуточные <DIV> будут пропущены. Сработает только событие mouseout на #FROM и mouseover на #TO.
На практике это полезно, потому что таких промежуточных элементов может быть много, и если обрабатывать заход и уход с каждого, будут дополнительные вычислительные затраты.
В частности, возможна ситуация, когда курсор прыгает в середину страницы, и при этом relatedTarget=null, то есть он пришёл «ниоткуда» (на самом деле извне окна):

Обратим внимание ещё на такую деталь. При быстром движении курсор окажется 
над #TO сразу, даже если этот элемент глубоко в DOM. Его родители при движении сквозь них события не поймают.*/


/*«Лишний» mouseout при уходе на потомка
Представьте ситуацию – курсор зашёл на элемент. Сработал mouseover на нём. 
Потом курсор идёт на дочерний… И, оказывается, на элементе-родителе 
при этом происходит mouseout! Как будто курсор с него ушёл, хотя он всего лишь перешёл на потомка.

При переходе на потомка срабатывает mouseout на родителе.
Согласно браузерной логике, курсор мыши может быть только над одним элементом – самым глубоким
в DOM (и верхним по z-index). Так что если он перешел куда-нибудь, то автоматически
ушёл с предыдущего элемента. Всё просто.*/

/*события mouseover и mouseout всплывают.
Получается, что если поставить обработчики mouseover и mouseout на #FROM и #TO,
то последовательность срабатывания при переходе #FROM → #TO будет следующей:

	1 mouseout на #FROM (с event.target=#FROM, event.relatedTarget=#TO).
	2 mouseover на #TO (с event.target=#TO, event.relatedTarget=#FROM).
	3 Событие mouseover после срабатывания на #TO всплывает выше, запуская обработчики mouseover на родителях. Ближайший родитель – как раз #FROM, то есть сработает обработчик mouseover на нём, с теми же значениями target/relatedTarget.
Если посмотреть на 1) и 3), то видно, что на #FROM сработает сначала mouseout, а затем с #TO всплывёт mouseover.
У обработчиков создаётся впечатление, что курсор ушёл mouseout с родителя, а затем тут же перешёл mouseover на него (за счёт всплытия mouseover с потомка).

Если же происходит что-то более сложное, то бывает важно отследить момент «настоящего» ухода,
то есть понять, когда элемент зашёл на родителя, а когда ушёл – без учёта переходов по дочерним элементам.*/



/*События mouseenter и mouseleave
События mouseenter/mouseleave похожи на mouseover/mouseout.
Они тоже срабатывают, когда курсор заходит на элемент и уходит с него, но с двумя отличиями.
	1_Не учитываются переходы внутри элемента.
	2_События mouseenter/mouseleave не всплывают.

Курсор заходит на элемент – срабатывает mouseenter, а затем – неважно, куда он внутри него переходит, mouseleave будет, когда курсор окажется за пределами элемента.*/


/*Делегирование
События mouseenter/leave более наглядны и понятны, но они не всплывают,
а значит с ними нельзя использовать делегирование.*/


/*Итого
У mouseover, mousemove, mouseout есть следующие особенности:
	-При быстром движении мыши события mouseover, mousemove, mouseout могут пропускать промежуточные элементы.
	-События mouseover и mouseout – единственные, у которых есть вторая цель: relatedTarget (toElement/fromElement в IE).
	-События mouseover/mouseout подразумевают, что курсор находится над одним, самым глубоким элементом. Они срабатывают при переходе с родительского элемента на дочерний.
События mouseenter/mouseleave не всплывают и не учитывают переходы внутри элемента.*/




























