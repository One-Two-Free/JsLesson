/*Мышь: Drag'n'Drop*/

/*Алгоритм Drag’n’Drop
Основной алгоритм Drag’n’Drop выглядит так:
	1_Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события mousedown.
	2_При нажатии – подготовить элемент к перемещению.
	3_Далее отслеживаем движение мыши через mousemove и передвигаем переносимый элемент на новые координаты путём смены left/top и position:absolute.
	4_При отпускании кнопки мыши, то есть наступлении события mouseup – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.

Особенность правильного Drag’n’Drop – событие mousemove отслеживается на document, а не на ball.
С первого взгляда кажется, что мышь всегда над мячом и обработчик mousemove можно повесить на сам мяч, а не на документ.
Однако, на самом деле мышь во время переноса не всегда над мячом.
Вспомним, событие mousemove возникает хоть и часто, но не для каждого пикселя. Быстрое движение курсора вызовет mousemove уже не над мячом, а, например, в дальнем конце страницы.
Вот почему мы должны отслеживать mousemove на всём document.

Для правильного переноса необходимо, чтобы изначальный сдвиг курсора относительно элемента сохранялся.
Где захватили, за ту «часть элемента» и переносим:

1 Когда человек нажимает на мячик mousedown – курсор сдвинут относительно левого-верхнего угла мяча на расстояние, которое мы обозначим shiftX/shiftY. И нужно при переносе сохранить этот сдвиг.
Получить значения shiftX/shiftY легко: достаточно вычесть из координат курсора pageX/pageY левую-верхнюю границу мячика, полученную при помощи функции getCoords.
При Drag’n’Drop мы везде используем координаты относительно документа, так как они подходят в большем количестве ситуаций.*/


/*Итого
Мы рассмотрели «минимальный каркас» Drag'n'Drop.
Его компоненты:
	- События ball.mousedown → document.mousemove → ball.mouseup.
	- Передвижение с учётом изначального сдвига shiftX/shiftY.
	- Отмена действия браузера по событию dragstart.
На этой основе можно сделать очень многое.
При mouseup можно обработать окончание переноса, произвести изменения в данных, если они нужны.
Во время самого переноса можно подсвечивать элементы, над которыми проходит элемент.
При обработке событий mousedown и mouseup можно использовать делегирование, так что одного обработчика достаточно для управления переносом в зоне с сотнями элементов.*/




































































