/*Основы XMLHttpRequest
Объект XMLHttpRequest (или, как его кратко называют, «XHR») дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.*/

/*Пример создания
Как правило, XMLHttpRequest используют для загрузки данных.*/
// 1. Создаём новый объект XMLHttpRequest
var xhr = new XMLHttpRequest();

/*Настроить: open
Синтаксис:*/
xhr.open(method, URL, async, user, password)
/*Этот метод – как правило, вызывается первым после создания объекта XMLHttpRequest.
Задаёт основные параметры запроса:
	method – HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде TRACE/DELETE/PUT и т.п.

	URL – адрес запроса. Можно использовать не только http/https, но и другие протоколы, например ftp:// и file://.	При этом есть ограничения безопасности, называемые «Same Origin Policy»: запрос со страницы можно отправлять только на тот же протокол://домен:порт, с которого она пришла. В следующих главах мы рассмотрим, как их можно обойти.

	async – если установлено в false, то запрос производится синхронно, если true – асинхронно.
«Синхронный запрос» означает, что после вызова xhr.send() и до ответа сервера главный поток будет «заморожен»: посетитель не сможет взаимодействовать со страницей – прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.
«Асинхронный запрос» означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий, которые мы рассмотрим далее.

	user, password – логин и пароль для HTTP-авторизации, если нужны.*/

/*Отослать данные: send
Синтаксис:*/
xhr.send([body])
/*Именно этод метод открывает соединение и отправляет запрос на сервер.
В body находится тело запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет,
а у POST – основные данные как раз передаются через body.*/

/*Отмена: abort
Вызов xhr.abort() прерывает выполнение запроса.*/

/*Ответ: status, statusText, responseText
Основные свойства, содержащие ответ сервера:

status
	HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен.
statusText
	Текстовое описание статуса от сервера: OK, Not Found, Forbidden и так далее.
responseText
	Текст ответа сервера.
	
Есть и ещё одно свойство, которое используется гораздо реже:
responseXML
	Если сервер вернул XML, снабдив его правильным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы xhr.responseXml.querySelector("...") и другие.*/

/*Синхронные и асинхронные запросы
Если в методе open установить параметр async равным false, то запрос будет синхронным.
Синхронные вызовы используются чрезвычайно редко, так как блокируют взаимодействие со страницей до окончания загрузки. Посетитель не может даже прокручивать её. Никакой JavaScript не может быть выполнен, пока синхронный вызов не завершён – в общем, в точности те же ограничения как alert.
Если синхронный вызов занял слишком много времени, то браузер предложит закрыть «зависшую» страницу.
Из-за такой блокировки получается, что нельзя отослать два запроса одновременно. Кроме того, забегая вперёд, заметим, что ряд продвинутых возможностей, таких как возможность делать запросы на другой домен и указывать таймаут, в синхронном режиме не работают.
Из всего вышесказанного уже должно быть понятно, что синхронные запросы используются чрезвычайно редко, а асинхронные – почти всегда.
Для того, чтобы запрос стал асинхронным, укажем параметр async равным true.*/

/*Событие readystatechange
Событие readystatechange происходит несколько раз в процессе отсылки и получения ответа. 
При этом можно посмотреть «текущее состояние запроса» в свойстве xhr.readyState.
Все состояния, по спецификации:*/
const unsigned short UNSENT = 0; // начальное состояние
const unsigned short OPENED = 1; // вызван open
const unsigned short HEADERS_RECEIVED = 2; // получены заголовки
const unsigned short LOADING = 3; // загружается тело (получен очередной пакет данных)
const unsigned short DONE = 4; // запрос завершён

/*Запрос проходит их в порядке 0 → 1 → 2 → 3 → … → 3 → 4, состояние 3 повторяется при каждом получении очередного пакета данных по сети.*/

/*Точка разрыва пакетов не гарантирована
При состоянии readyState=3 (получен очередной пакет) мы можем посмотреть текущие данные в responseText и, казалось бы, могли бы работать с этими данными как с «ответом на текущий момент».
Однако, технически мы не управляем разрывами между сетевыми пакетами. Если протестировать пример выше в локальной сети, то в большинстве браузеров разрывы будут каждые 1000 символов, но в реальности пакет может прерваться на любом байте.
Чем это опасно? Хотя бы тем, что символы русского языка в кодировке UTF-8 кодируются двумя байтами каждый – и разрыв может возникнуть между ними.
Получится, что при очередном readyState в конце responseText будет байт-полсимвола, то есть он не будет корректной строкой – частью ответа! Если в скрипте как-то по-особому это не обработать, то неизбежны проблемы.*/


/*HTTP-заголовки
XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
Для работы с HTTP-заголовками есть 3 метода:
	setRequestHeader(name, value)
Устанавливает заголовок name запроса со значением value.*/
xhr.setRequestHeader('Content-Type', 'application/json');
/*Ограничения на заголовки
Нельзя установить заголовки, которые контролирует браузер, например Referer или Host и ряд других
Поставленный заголовок нельзя снять
Особенностью XMLHttpRequest является то, что отменить setRequestHeader невозможно.*/

	/*getResponseHeader(name)
Возвращает значение заголовка ответа name, кроме Set-Cookie и Set-Cookie2.*/
xhr.getResponseHeader('Content-Type')

	/*getAllResponseHeaders()
Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.
Заголовки возвращаются в виде единой строки, например:
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT

Между заголовками стоит перевод строки в два символа "\r\n" (не зависит от ОС), значение заголовка отделено двоеточием с пробелом ": ". Этот формат задан стандартом.
Таким образом, если хочется получить объект с парами заголовок-значение, то эту строку необходимо разбить и обработать.*/

/*Таймаут
Максимальную продолжительность асинхронного запроса можно задать свойством timeout:*/
xhr.timeout = 30000; // 30 секунд (в миллисекундах)

/*При превышении этого времени запрос будет оборван и сгенерировано событие ontimeout:*/
xhr.ontimeout = function() {
  alert( 'Извините, запрос превысил максимальное время' );
}

/*Полный список событий
Современная спецификация предусматривает следующие события по ходу обработки запроса:
	loadstart – запрос начат.
	progress – браузер получил очередной пакет данных, можно прочитать текущие полученные данные в responseText.
	abort – запрос был отменён вызовом xhr.abort().
	error – произошла ошибка.
	load – запрос был успешно (без ошибок) завершён.
	timeout – запрос был прекращён по таймауту.
	loadend – запрос был завершён (успешно или неуспешно)
Используя эти события можно более удобно отслеживать загрузку (onload) и ошибку (onerror), а также количество загруженных данных (onprogress).
Ранее мы видели ещё одно событие – readystatechange. Оно появилось гораздо раньше, ещё до появления текущего стандарта.*/















