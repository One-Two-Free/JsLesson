/*Генераторы
Генераторы – новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени. 
Для объявления генератора используется новая синтаксическая конструкция: function* (функция со звёздочкой).Её называют «функция-генератор» (generator function).*/
function* generateSequence() {
  yield 1;  yield 2;  return 3; }

/*При запуске generateSequence() код такой функции не выполняется. 
Вместо этого она возвращает специальный объект, который как раз и называют «генератором».*/
// generator function создаёт generator
let generator = generateSequence();
/*При создании генератора код находится в начале своего выполнения.
Основным методом генератора является next(). При вызове он возобновляет выполнение кода до ближайшего ключевого слова yield. По достижении yield выполнение приостанавливается, а значение – возвращается во внешний код:*/
function* generateSequence() {
  yield 1;  yield 2;  return 3;}
let generator = generateSequence();
let one = generator.next();
alert(JSON.stringify(one)); // {value: 1, done: false}
//Повторный вызов generator.next() возобновит выполнение и вернёт результат следующего yield:
let two = generator.next();
alert(JSON.stringify(two)); // {value: 2, done: false}
//И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
let three = generator.next();
alert(JSON.stringify(three)); // {value: 3, done: true}
/*Функция завершена. Внешний код должен увидеть это из свойства done:true и обработать value:3, как окончательный результат.*/


/*Генератор – итератор
Как вы, наверно, уже догадались по наличию метода next(), генератор связан с итераторами. В частности, он является итерируемым объектом.
Его можно перебирать и через for..of:*/
function* generateSequence() {
  yield 1;  yield 2;  return 3;}
let generator = generateSequence();
for(let value of generator) {  alert(value); // 1, затем 2
}
/*Заметим, однако, существенную особенность такого перебора!
При запуске примера выше будет выведено значение 1, затем 2. Значение 3 выведено не будет. Это потому что стандартный перебор итератора игнорирует value на последнем значении, при done: true. Так что результат return в цикле for..of не выводится.
Соответственно, если мы хотим, чтобы все значения возвращались при переборе через for..of, то надо возвращать их через yield:*/






/*Композиция генераторов
Один генератор может включать в себя другие. Это называется композицией.
Пусть у нас есть функция generateSequence, которая генерирует последовательность чисел:*/
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) { yield i; }}
// Используем оператор … для преобразования итерируемого объекта в массив
let sequence = [...generateSequence(2,5)];
alert(sequence); // 2, 3, 4, 5
/*Мы хотим на её основе сделать другую функцию generateAlphaNum(),
которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:
48..57 – для 0..9   65..90 – для A..Z    97..122 – для a..z
Далее этот набор кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации ещё хорошо бы добавить для надёжности, но в этом примере мы будем без них.*/

function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i; }

function* generateAlphaNum() {
  // 0..9
  yield* generateSequence(48, 57);
  // A..Z
  yield* generateSequence(65, 90);
  // a..z
  yield* generateSequence(97, 122);}
let str = '';
for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);}
alert(str); // 0..9A..Za..z

/*Здесь использована специальная форма yield*. Она применима только к другому генератору и делегирует ему выполнение.
То есть, при yield* интерпретатор переходит внутрь генератора-аргумента, к примеру, generateSequence(48, 57), выполняет его, и все yield, которые он делает, выходят из внешнего генератора.
Получается – как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:*/
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;}

function* generateAlphaNum() {
  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;
  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;
  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;
}
let str = '';
for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}
alert(str); // 0..9A..Za..z

/*Композиция – это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются «по мере готовности». Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.*/


/*yield – дорога в обе стороны
 он не только возвращает результат наружу, но и может передавать значение извне в генератор.
Вызов let result = yield value делает следующее:
  - Возвращает value во внешний код, приостанавливая выполнение генератора.
  - Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
  - Генератор продолжит выполнение, аргумент next будет возвращён как результат yield (и записан в result).*/

function* gen() {
  // Передать вопрос во внешний код и подождать ответа
  let result = yield "2 + 2?";
  alert(result);
}
let generator = gen();
let question = generator.next().value;
// "2 + 2?"
setTimeout(() => generator.next(4), 2000);

/*
1 Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат первого yield («2+2?»). На этой точке генератор приостанавливает выполнение.
2 Результат yield переходит во внешний код (в question). Внешний код может выполнять любые асинхронные задачи, генератор стоит «на паузе».
3 Когда асинхронные задачи готовы, внешний код вызывает generator.next(4) с аргументом. Выполнение генератора возобновляется, а 4 выходит из присваивания как результат let result = yield ....


Получается «пинг-понг»: каждый next(value) передаёт в генератор значение, которое становится результатом текущего yield, возобновляет выполнение и получает выражение из следующего yield. Исключением является первый вызов next, который не может передать значение в генератор, т.к. ещё не было ни одного yield.*/





/*generator.throw
внешний код может вернуть генератору в качестве результата yield любое значение.
…Но «вернуть» можно не только результат, но и ошибку!
Для того, чтобы передать в yield ошибку, используется вызов generator.throw(err). При этом на строке с yield возникает исключение.*/

function* gen() {
  try {
    // в этой строке возникнет ошибка
    let result = yield "Сколько будет 2 + 2?"; // (**)

    alert("выше будет исключение ^^^");
  } catch(e) {
    alert(e); // выведет ошибку
  }
}

let generator = gen();
let question = generator.next().value;
generator.throw(new Error("ответ не найден в моей базе данных")); // (*)

/*«Вброшенная» в строке (*) ошибка возникает в строке с yield (**). Далее она обрабатывается как обычно. В примере выше она перехватывается try..catch и выводится.
Если ошибку не перехватить, то она «выпадет» из генератора. По стеку ближайший вызов, который инициировал выполнение – это строка с .throw. Можно перехватить её там, как и продемонстрировано в примере ниже:*/
function* gen() {
  // В этой строке возникнет ошибка
  let result = yield "Сколько будет 2 + 2?";
}

let generator = gen();
let question = generator.next().value;
try {  generator.throw(new Error("ответ не найден в моей базе данных"));} 
catch(e) {
  alert(e); // выведет ошибку
}
//Если же ошибка и там не перехвачена, то дальше – как обычно, либо try..catch снаружи, либо она «повалит» скрипт.




/*Плоский асинхронный код
Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
Общий принцип такой:
  - Генератор yield'ит не просто значения, а промисы.
  - Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
  - Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.*/

// генератор для получения и показа аватара
// он yield'ит промисы
function* showUserAvatar() {

  let userFetch = yield fetch('/article/generator/user.json');
  let userInfo = yield userFetch.json();

  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`);
  let githubUserInfo = yield githubFetch.json();

  let img = new Image();
  img.src = githubUserInfo.avatar_url;
  img.className = "promise-avatar-example";
  document.body.appendChild(img);

  yield new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return img.src;
}

// вспомогательная функция-чернорабочий
// для выполнения промисов из generator
function execute(generator, yieldValue) {

  let next = generator.next(yieldValue);

  if (!next.done) {
    next.value.then(
      result => execute(generator, result),
      err => generator.throw(err)
    );
  } else {
    // обработаем результат return из генератора
    // обычно здесь вызов callback или что-то в этом духе
    alert(next.value);
  }
}
execute( showUserAvatar() );

/*Функция execute в примере выше – универсальная, она может работать с любым генератором, который yield'ит промисы.
Вместе с тем, это – всего лишь набросок, чтобы было понятно, как такая функция в принципе работает. Есть уже готовые реализации, обладающие большим количеством возможностей.
Одна из самых известных – это библиотека co, которую мы рассмотрим далее.*/















