/*Итераторы
Итерируемые или, иными словами, «перебираемые» объекты – это те, содержимое которых можно
перебрать в цикле. Для перебора таких объектов добавлен новый синтаксис цикла: for..of.

Практически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя
не только строки, массивы, но и вызов функции с оператором spread f(...args), и многое другое.

Для возможности использовать объект в for..of нужно создать в нём свойство с названием Symbol.iterator (системный символ).

При вызове метода Symbol.iterator перебираемый объект должен возвращать другой объект («итератор»), который умеет осуществлять перебор.

По стандарту у такого объекта должен быть метод next(), который при каждом вызове возвращает очередное значение и проверяет, окончен ли перебор.*/

'use strict';

let range = { from: 1,  to: 5 }

// сделаем объект range итерируемым
range[Symbol.iterator] = function() {

  let current = this.from;
  let last = this.to;

  // метод должен вернуть объект с методом next()
  return {
    next() {
      if (current <= last) {
        return { done: false, value: current++ };
      } else {
        return { done: true };
      }
    }
  }
};
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}

/*Как видно из кода выше, здесь имеет место разделение сущностей:

  Перебираемый объект range сам не реализует методы для своего перебора.
  Для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется итератором и возвращается при вызове метода range[Symbol.iterator].
  У итератора должен быть метод next(), который при каждом вызове возвращает объект со свойствами:
    value – очередное значение,
    done – равно false если есть ещё значения, и true – в конце.

Конструкция for..of в начале своего выполнения автоматически вызывает Symbol.iterator(), получает итератор и далее вызывает метод next() до получения done: true. Такова внутренняя механика. Внешний код при переборе через for..of видит только значения.


*/
















