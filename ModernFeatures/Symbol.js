/*Синтаксис:
let sym = Symbol();
Обратим внимание, не new Symbol, а просто Symbol, так как это – примитив.
У символов есть и соответствующий typeof:*/
'use strict';
let sym = Symbol();
alert( typeof sym ); // symbol

/*Каждый символ – уникален. У функции Symbol есть необязательный аргумент «имя символа». 
Его можно использовать для описания символа, в целях отладки:*/
'use strict';
let sym = Symbol("name");
alert( sym.toString() ); // Symbol(name)

/*Но при этом, если у двух символов одинаковое имя, то это не значит, что они равны:*/
alert( Symbol("name") == Symbol("name") ); // false

/*Если хочется из разных частей программы использовать именно одинаковый символ, 
то можно передавать между ними объект символа или же – использовать «глобальные символы» 
и «реестр глобальных символов», которые мы рассмотрим далее.*/

/*Глобальные символы
Существует «глобальный реестр» символов, который позволяет, 
при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.
Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).
Например:*/
'use strict';
// создание символа в реестре
let name = Symbol.for("name");
// символ уже есть, чтение из реестра
alert( Symbol.for("name") == name ); // true
/*Таким образом, можно из разных частей программы, обратившись к реестру, 
получить единый глобальный символ с именем "name".
У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym).
Он позволяет получить по глобальному символу его имя:*/
'use strict';
// создание символа в реестре
let test = Symbol.for("name");
// получение имени символа
alert( Symbol.keyFor(test) ); // name

/*Symbol.keyFor возвращает undefined, если символ не глобальный
Заметим, что Symbol.keyFor работает только для глобальных символов, 
для остальных будет возвращено undefined:*/
'use strict';
alert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный
alert( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ
/*Таким образом, имя символа, если этот символ не глобальный, 
не имеет особого применения, оно полезно лишь в целях вывода и отладки.*/

/*Использование символов
Символы можно использовать в качестве имён для свойств объекта следующим образом:*/
'use strict';
let isAdmin = Symbol("isAdmin");
let user = {
  name: "Вася",
  [isAdmin]: true
};
alert(user[isAdmin]); // true

















































































