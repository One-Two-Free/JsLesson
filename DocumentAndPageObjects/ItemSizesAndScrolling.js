/*Размеры и прокрутка элементов

	Образец документа
Мы будем использовать для примера вот такой элемент, у которого есть рамка (border), 
поля (padding), и прокрутка:
*/
<div id="example">  ...Текст... </div>
<style>  #example {
    width: 300px;
    height: 200px;
    border: 25px solid #E8C48F; /* рамка 25px */
    padding: 20px;              /* поля 20px */
    overflow: auto;             /* прокрутка */
  }</style>
/*У него нет отступов margin, в этой главе они не важны, так как метрики 
касаются именно размеров самого элемента, отступы в них не учитываются.*/

	/*Метрики
У элементов существует ряд свойств, содержащих их внешние и внутренние размеры. 
Мы будем называть их «метриками». Метрики, в отличие от свойств CSS, содержат числа, 
всегда в пикселях и без единиц измерения на конце.

	offsetParent, offsetLeft/Top
Ситуации, когда эти свойства нужны, можно перечислить по пальцам. Они возникают действительно редко.

	В offsetParent находится ссылка на родительский элемент в смысле отображения на странице.
Уточним, что имеется в виду.
Когда браузер рисует страницу, то он высчитывает дерево расположения элементов, иначе говоря «дерево геометрии» или «дерево рендеринга», которое содержит всю информацию о размерах.
При этом одни элементы естественным образом рисуются внутри других. Но, к примеру, если у элемента стоит position:absolute, то его расположение вычисляется уже не относительно непосредственного родителя parentNode, а относительно ближайшего позиционированного элемента (т.е. свойство position которого не равно static), или BODY, если такой отсутствует.
Получается, что элемент имеет в дополнение к обычному родителю в DOM – ещё одного «родителя по позиционированию», то есть относительно которого он рисуется. Этот элемент и будет в свойстве offsetParent.
	Свойства offsetLeft/Top задают смещение относительно offsetParent.
В примере ниже внутренний <div> имеет DOM-родителя <form>, но offsetParent у него <main>, и сдвиги относительно его верхнего-левого угла будут в offsetLeft/Top:*/
<main style="position: relative">
  <form>  <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </form></main>
	/*offsetWidth/Height
Теперь переходим к самому элементу. Эти два свойства – самые простые. 
Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки border.
Для нашего элемента:
	offsetWidth = 390 – внешняя ширина блока, её можно получить сложением CSS-ширины (300px, но её часть на рисунке выше отнимает прокрутка, поэтому 284 + 16), полей(2*20px) и рамок (2*25px).
	offsetHeight = 290 – внешняя высота блока.*/

/*Метрики для невидимых элементов равны нулю.
Координаты и размеры в JavaScript устанавливаются только для видимых элементов.
Для элементов с display:none или находящихся вне документа дерево рендеринга не строится. 
Для них метрики равны нулю. Кстати, и offsetParent для таких элементов тоже null.
Это дает нам замечательный способ для проверки, виден ли элемент:*/
function isHidden(elem) {  return !elem.offsetWidth && !elem.offsetHeight; }
/*Работает, даже если родителю элемента установлено свойство display:none.
Работает для всех элементов, кроме TR, с которым возникают некоторые проблемы в разных браузерах. 
Обычно, проверяются не TR, поэтому всё ок.
Считает элемент видимым, даже если позиционирован за пределами экрана или имеет свойство visibility:hidden.
«Схлопнутый» элемент, например пустой div без высоты и ширины, будет считаться невидимым.*/

	/*clientTop/Left
Далее внутри элемента у нас рамки border.
Для них есть свойства-метрики clientTop и clientLeft.
В нашем примере:
clientLeft = 25 – ширина левой рамки
clientTop = 25 – ширина верхней рамки

…Но на самом деле они – вовсе не рамки, а отступ внутренней части элемента от внешней.
В чём же разница?
Она возникает тогда, когда документ располагается справа налево (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство clientLeft включает в себя еще и ширину полосы прокрутки.*/

/*clientWidth/Height
Эти свойства – размер элемента внутри рамок border.
Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.

На рисунке выше посмотрим вначале на clientHeight, её посчитать проще всего. Прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота 200px плюс верхнее и нижнее поля padding (по 20px), итого 240px.
На рисунке нижний padding заполнен текстом, но это неважно: по правилам он всегда входит в clientHeight.
Теперь clientWidth – ширина содержимого здесь не равна CSS-ширине, её часть «съедает» полоса прокрутки. Поэтому в clientWidth входит не CSS-ширина, а реальная ширина содержимого 284px плюс левое и правое поля padding (по 20px), итого 324px.

Если padding нет, то clientWidth/Height в точности равны размеру области содержимого, внутри рамок и полосы прокрутки. Поэтому в тех случаях, когда мы точно знаем, что padding нет, их используют для определения внутренних размеров элемента.*/

/*scrollWidth/Height
Эти свойства – аналоги clientWidth/clientHeight, но с учетом прокрутки.
Свойства clientWidth/clientHeight относятся только к видимой области элемента, 
а scrollWidth/scrollHeight добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.

На рисунке выше:
scrollHeight = 723 – полная внутренняя высота, включая прокрученную область.
scrollWidth = 324 – полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна clientWidth.
Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту, таким кодом:*/
element.style.height = element.scrollHeight + 'px';

/*scrollLeft/scrollTop
Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.
Следующая иллюстрация показывает значения scrollHeight и scrollTop для блока с вертикальной прокруткой.*/

	/*scrollLeft/scrollTop можно изменять
В отличие от большинства свойств, которые доступны только для чтения, значения scrollLeft/scrollTop можно изменить, и браузер выполнит прокрутку элемента.
При клике на следующий элемент будет выполняться код elem.scrollTop += 10. Поэтому он будет прокручиваться на 10px вниз:*/

	/*Не стоит брать width/height из CSS
Как мы знаем, CSS-высоту и ширину можно установить с помощью elem.style и извлечь, 
используя getComputedStyle, которые в подробностях обсуждаются в главе Стили, getComputedStyle.
Получение ширины элемента может быть таким:*/
var elem = document.body;
alert( getComputedStyle(elem).width ); // вывести CSS-ширину для elem
/*Не лучше ли получать ширину так, вместо метрик? Вовсе нет!
	Во-первых, CSS-свойства width/height зависят от другого свойства – box-sizing, которое определяет, что такое, собственно, эти ширина и высота. Получается, что изменение box-sizing, к примеру, для более удобной вёрстки, сломает такой JavaScript.
	Во-вторых, в CSS свойства width/height могут быть равны auto, например, для инлайн-элемента:*/
<span id="elem">Привет!</span><script>  alert( getComputedStyle(elem).width ); // auto
</script>
/*Конечно, с точки зрения CSS размер auto – совершенно нормально, но нам-то в JavaScript нужен конкретный размер в пикселях, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина width из CSS вообще бесполезна.
Есть и ещё одна причина.
Полоса прокрутки – причина многих проблем и недопониманий. Как говорится, «дьявол кроется в деталях». Недопустимо, чтобы наш код работал на элементах без прокрутки и начинал «глючить» с ней.

Получается, что реальная ширина содержимого меньше CSS-ширины. И это учитывают свойства clientWidth/clientHeight.*/

/*Итого
У элементов есть следующие метрики:

	offsetParent – «родитель по дереву рендеринга» – ближайшая ячейка таблицы, body для статического позиционирования или ближайший позиционированный элемент для других типов позиционирования.
	offsetLeft/offsetTop – позиция в пикселях левого верхнего угла блока, относительно его offsetParent.
	offsetWidth/offsetHeight – «внешняя» ширина/высота блока, включая рамки.
	clientLeft/clientTop – отступ области содержимого от левого-верхнего угла элемента. Если операционная система располагает вертикальную прокрутку справа, то равны ширинам левой/верхней рамки, если же слева (ОС на иврите, арабском), то clientLeft включает в себя прокрутку.
	Метрики для внутренней зоны
	clientWidth/clientHeight – ширина/высота содержимого вместе с полями padding, но без полосы прокрутки.
	scrollWidth/scrollHeight – ширина/высота содержимого, включая прокручиваемую область. Включает в себя padding и не включает полосы прокрутки.
	scrollLeft/scrollTop – ширина/высота прокрученной части документа, считается от верхнего левого угла.
	
	Клиентская область - это то что внутри border, включает паддинг. Второе offset весь бокс. 
	clientWidth/clientHeight клиентская ширина/высота
	clientLeft/clientTop отступ клиентской области от внешних границ элемента
	offsetWidth/offsetHeight – размеры целиком элемента, с учетом рамок
	
	
Все свойства, доступны только для чтения, кроме scrollLeft/scrollTop. 
Изменение этих свойств заставляет браузер прокручивать элемент.*/







