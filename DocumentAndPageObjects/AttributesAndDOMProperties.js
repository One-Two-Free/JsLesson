	/*Атрибуты и DOM-свойства
При чтении HTML браузер генерирует DOM-модель. При этом большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов.
Например, если тег выглядит как <body id="page">, то у объекта будет свойство body.id = "page".
Но это преобразование – не один-в-один. Бывают ситуации, когда атрибут имеет одно значение, а свойство – другое. Бывает и так, что атрибут есть, а свойства с таким названием не создаётся.
Если коротко – HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу, нужно понимать, что такое свойство и что такое атрибут, чтобы работать с ними правильно.*/

	/*Свои DOM-свойства
Узел DOM – это объект, поэтому, как и любой объект в JavaScript, 
он может содержать пользовательские свойства и методы.

Нестандартные свойства и методы видны только в JavaScript и никак не влияют 
на отображение соответствующего тега.

Обратим внимание, пользовательские DOM-свойства:
	Могут иметь любое значение.
	Названия свойств чувствительны к регистру.
	Работают за счет того, что DOM-узлы являются объектами JavaScript.*/

/*Атрибуты
Элементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.
Конечно, здесь речь именно об узлах-элементах, не о текстовых узлах или комментариях.
Доступ к атрибутам осуществляется при помощи стандартных методов:
	elem.hasAttribute(name) – проверяет наличие атрибута
	elem.getAttribute(name) – получает значение атрибута
	elem.setAttribute(name, value) – устанавливает атрибут
	elem.removeAttribute(name) – удаляет атрибут
	
Эти методы работают со значением, которое находится в HTML!
Также все атрибуты элемента можно получить с помощью свойства elem.attributes, 
которое содержит псевдо-массив объектов типа Attr.
В отличие от свойств, атрибуты:
	Всегда являются строками.
	Их имя нечувствительно к регистру (ведь это HTML)
	Видны в innerHTML (за исключением старых IE)*/

/*обратите внимание:

	getAttribute('About') – первая буква имени атрибута About написана в верхнем регистре, а в HTML – в нижнем, но это не имеет значения, так как имена нечувствительны к регистру.
	
	Мы можем записать в атрибут любое значение, но оно будет превращено в строку. Объекты также будут автоматически преобразованы.
	
	После добавления атрибута его можно увидеть в innerHTML элемента.
	
	Коллекция attributes содержит все атрибуты в виде объектов со свойствами name и value.*/


/*Когда полезен доступ к атрибутам?
Когда браузер читает HTML и создаёт DOM-модель, то он создаёт свойства для всех стандартных атрибутов.
Все стандартные свойства DOM синхронизируются с атрибутами, однако не всегда такая синхронизация
происходит 1-в-1, поэтому иногда нам нужно значение именно из HTML, то есть атрибут.

Ссылка «как есть» из атрибута href
Синхронизация не гарантирует одинакового значения в атрибуте и свойстве.
Для примера, посмотрим, что произойдет с атрибутом "href" при изменении свойства:*/
<a id="a" href="#"></a>
<script>
  a.href = '/';
  alert( 'атрибут:' + a.getAttribute('href') ); // '/'
  alert( 'свойство:' + a.href );  // полный URL
</script>
/*Стало быть, если мы хотим именно то, что в HTML, то нужно обращаться через атрибут.
Есть и другие подобные атрибуты
Кстати, есть и другие атрибуты, которые не копируются в точности. 
Например, DOM-свойство input.checked имеет логическое значение true/false, 
а HTML-атрибут checked – любое строковое, важно лишь его наличие.
Работа с checked через атрибут и свойство:*/
<input id="input" type="checkbox" checked>
<script>
  // работа с checked через атрибут
  alert( input.getAttribute('checked') ); // пустая строка
  input.removeAttribute('checked'); // снять галочку
  // работа с checked через свойство
  alert( input.checked ); // false <-- может быть только true/false
  input.checked = true; // поставить галочку (при этом атрибут в элементе не появится)
</script>


	/*Исходное значение value
Изменение некоторых свойств обновляет атрибут. Но это скорее исключение, чем правило.
Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот
Например, при изменении свойства input.value атрибут input.getAttribute('value') не меняется:
<body>
  <input id="input" type="text" value="markup">
  <script>
    input.value = 'new'; // поменяли свойство

    alert( input.getAttribute('value') ); // 'markup', не изменилось!
  </script>
</body>
Эту особенность можно красиво использовать.
Получается, что атрибут input.getAttribute('value') хранит оригинальное (исходное) значение даже после того, как пользователь заполнил поле и свойство изменилось.
Например, можно взять изначальное значение из атрибута и сравнить со свойством, чтобы узнать, изменилось ли значение. А при необходимости и перезаписать свойство атрибутом, отменив изменения.
*/

	/*Классы в виде строки: className
Атрибуту "class" соответствует свойство className.
*/


	/*Классы в виде объекта: classList
Работать с классами как со строкой неудобно. 
Поэтому, кроме className, в современных браузерах есть свойство classList.
Свойство classList – это объект для работы с классами.
Оно поддерживается в IE начиная с IE10, но его можно эмулировать в IE8+, 
подключив мини-библиотеку classList.js.

Методы classList:
	elem.classList.contains("class") – возвращает true/false, в зависимости от того, 
	есть ли у элемента класс class.
	elem.classList.add/remove("class") – добавляет/удаляет класс class
	elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.
	
Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.*/


/*Нестандартные атрибуты
Для нестандартных атрибутов DOM-свойство не создаётся.*/
<div id="elem" href="http://ya.ru" about="Elephant"></div>
<script>
  alert( elem.id ); // elem
  alert( elem.about ); // undefined
</script>

	/*Свойство dataset, data-атрибуты
С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.
Как правило, это делается при помощи атрибутов с названиями, начинающимися на data-, например:*/
<div id="elem" data-about="Elephant" data-user-location="street">
  По улице прошёлся слон. Весьма красив и толст был он.
</div>
<script>
  alert( elem.getAttribute('data-about') ); // Elephant
  alert( elem.getAttribute('data-user-location') ); // street
</script>
/*Стандарт HTML5 специально разрешает атрибуты data-* и резервирует их для пользовательских данных.
При этом во всех браузерах, кроме IE10-, к таким атрибутам можно обратиться не только как к атрибутам,
но и как к свойствам, при помощи специального свойства dataset:*/
<div id="elem" data-about="Elephant" data-user-location="street">  По улице прошёлся слон. Весьма красив и толст был он.</div>
<script>
  alert( elem.dataset.about ); // Elephant
  alert( elem.dataset.userLocation ); // street
</script>
/*Обратим внимание – название data-user-location трансформировалось в dataset.userLocation. 
Дефис превращается в большую букву.*/


/*Итого
	Атрибуты – это то, что написано в HTML.
	Свойство – это то, что находится внутри DOM-объекта.
Таблица сравнений для атрибутов и свойств:


Свойства					Атрибуты
Любое значение				Строка
Названия регистрозависимы	Не чувствительны к регистру
Не видны в innerHTML		Видны в innerHTML

Синхронизация между атрибутами и свойствами:
Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM. Некоторые свойства синхронизируются в обе стороны.
Бывает так, что свойство не совсем соответствует атрибуту. Например, «логические» свойства вроде checked, selected всегда имеют значение true/false, а в атрибут можно записать произвольную строку.Выше мы видели другие примеры на эту тему, например href.

Нестандартные атрибуты:
	Нестандартный атрибут (если забыть глюки старых IE) никогда не попадёт в свойство, так что для кросс-браузерного доступа к нему нужно обязательно использовать getAttribute.
	Атрибуты, название которых начинается с data-, можно прочитать через dataset. Эта возможность не поддерживается IE10-.
	
Для того, чтобы избежать проблем со старыми IE, а также для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты – только там, где это действительно нужно.

А действительно нужны атрибуты очень редко – лишь в следующих трёх случаях:
	Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.
	Когда нужно получить «оригинальное значение» стандартного HTML-атрибута, например, <input value="...">.
	Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция attributes.
Если вы хотите использовать собственные атрибуты в HTML, то помните, что атрибуты с именем, начинающимся на data- валидны в HTML5 и современные браузеры поддерживают доступ к ним через свойство dataset.*/













