/*Доступ к DOM начинается с объекта document. Из него можно добраться до любых узлов.
Сверху documentElement и body
Самые верхние элементы дерева доступны напрямую из document.
<HTML> = document.documentElement
Первая точка входа – document.documentElement. Это свойство ссылается на DOM-объект для тега <html>.
<BODY> = document.body
Вторая точка входа – document.body, который соответствует тегу <body>.
В современных браузерах (кроме IE8-) также есть document.head – прямая ссылка на <head>
Есть одна тонкость: document.body может быть равен null
Нельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.
В частности, если скрипт находится в <head>, то в нём недоступен document.body.
Поэтому в следующем примере первый alert выведет null:

В DOM активно используется null
В мире DOM в качестве значения, обозначающего «нет такого элемента» или 
«узел не найден», используется не undefined, а null.*/


/*Дети: childNodes, firstChild, lastChild
Здесь и далее мы будем использовать два принципиально разных термина.
Дочерние элементы (или дети) – элементы, которые лежат непосредственно внутри данного. 
Например, внутри <HTML> обычно лежат <HEAD> и <BODY>.
Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми 
их детей и так далее. То есть, всё поддерево DOM.

Список детей – только для чтения!
Скажем больше – все навигационные свойства, которые перечислены в этой главе – только для чтения. 
Нельзя просто заменить элемент присвоением childNodes[i] = ....
Изменение DOM осуществляется другими методами, которые мы рассмотрим далее, 
все навигационные ссылки при этом обновляются автоматически.

Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу.
При наличии дочерних узлов всегда верно:*/
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild


/*Коллекции – не массивы
В них нет методов массивов, таких как forEach, map, push, pop и других.
Можно для перебора коллекции использовать обычный цикл for(var i=0; i<elems.length; i++) ... 
Но что делать, если уж очень хочется воспользоваться методами массива?

Это возможно, основных варианта два:
	1 Применить метод массива через call/apply:*/
var elems = document.documentElement.childNodes;
[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
})

	2 При помощи Array.prototype.slice сделать из коллекции массив.
	Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr 
	с индексами от a до b-1 включительно. Если же вызвать его без 
	аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr.
	Это работает и для коллекции:
var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив
elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});

/*Соседи и родитель
Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling.
Родитель доступен через parentNode. Если долго идти от одного элемента к другому,
то рано или поздно дойдёшь до корня DOM, то есть до document.documentElement, а затем и document.*/



/*Навигация только по элементам
для большинства задач текстовые узлы нам не интересны.
Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:
	children – только дочерние узлы-элементы, то есть соответствующие тегам.
	firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
	previousElementSibling, nextElementSibling – соседи-элементы.
	parentElement – родитель-элемент.*/

/*Зачем parentElement?
Неужели бывают родители не-элементы?
Свойство elem.parentNode возвращает родитель элемента.
Оно всегда равно parentElement, кроме одного исключения:*/
alert( document.documentElement.parentNode ); // document
alert( document.documentElement.parentElement ); // null
/*Иногда это имеет значение, если хочется перебрать всех предков и вызвать
какой-то метод, а на документе его нет.*/


/*В IE8- поддерживается только children
Других навигационных свойств в этих браузерах нет. 
Впрочем, как мы увидим далее, можно легко сделать полифилл, и они, всё же, будут.

В IE8- в children присутствуют узлы-комментарии
С точки зрения стандарта это ошибка, но IE8- также включает в children узлы, 
соответствующие HTML-комментариям.
Это может привести к сюрпризам при использовании свойства children, 
поэтому HTML-комментарии либо убирают либо используют фреймворк, 
к примеру, jQuery, который даёт свои методы перебора и отфильтрует их.*/

/*Особые ссылки для таблиц
У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.
Здесь мы рассмотрим таблицу, так как это важный частный случай и просто для примера. В списке ниже выделены наиболее полезные:
TABLE
	table.rows – коллекция строк TR таблицы.
	table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
	table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.
THEAD/TFOOT/TBODY
	tbody.rows – коллекция строк TR секции.
TR
	tr.cells – коллекция ячеек TD/TH
	tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
	tr.rowIndex – номер строки в таблице
TD/TH
	td.cellIndex – номер ячейки в строке
	
Аналогичные полезные свойства есть у HTML-форм, они позволяют из формы
получить все её элементы, а из них – в свою очередь, форму. */














