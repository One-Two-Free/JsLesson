/*document.getElementById или просто id
Если элементу назначен специальный атрибут id, 
то можно получить его прямо по переменной с именем из значения id.*/
/*
<div id="content-holder"> <div id="content">Элемент</div></div>
<script>
  alert( content ); // DOM-элемент
  alert( window['content-holder'] ); // в имени дефис, поэтому через [...]
</script>
*/

/*Оно существует, в первую очередь, для совместимости, как осколок далёкого прошлого и
не очень приветствуется, поскольку использует глобальные переменные.
Браузер пытается помочь нам, смешивая пространства имён JS и DOM, но при этом возможны конфликты.

Более правильной и общепринятой практикой является доступ к элементу вызовом document.getElementById("идентификатор").*/

/*Должен остаться только один
По стандарту значение id должно быть уникально, то есть в документе может быть 
только один элемент с данным id. И именно он будет возвращён.
Если в документе есть несколько элементов с уникальным id, то поведение неопределено.
То есть, нет гарантии, что браузер вернёт именно первый или последний – вернёт случайным образом.
Поэтому стараются следовать правилу уникальности id.*/


/*getElementsByTagName
Метод elem.getElementsByTagName(tag) ищет все элементы с заданным тегом tag
внутри элемента elem и возвращает их в виде списка.
Регистр тега не имеет значения.*/
// получить все div-элементы
var elements = document.getElementsByTagName('div');
	/*Обратим внимание: в отличие от getElementById, который существует только
	в контексте document, метод getElementsByTagName может искать внутри любого элемента.*/
/*Можно получить всех потомков, передав звездочку '*' вместо тега:*/
// получить все элементы документа
document.getElementsByTagName('*');
// получить всех потомков элемента elem:
elem.getElementsByTagName('*');

/*Не забываем про букву "s"!
Одна из самых частых ошибок начинающих (впрочем, иногда и не только) – это забыть букву "s", то есть пробовать вызывать метод getElementByTagName вместо getElementsByTagName.
Буква "s" не нужна там, где элемент только один, то есть в getElementById, в остальных методах она обязательна.*/

/*Возвращается коллекция, а не элемент
Другая частая ошибка – это код вида:*/
// не работает
document.getElementsByTagName('input').value = 5;
/*То есть, вместо элемента присваивают значение коллекции. Работать такое не будет.
Коллекцию нужно или перебрать в цикле или получить элемент по номеру 
и уже ему присваивать value, например так:*/
// работает
document.getElementsByTagName('input')[0].value = 5;


/*document.getElementsByName
Вызов document.getElementsByName(name) позволяет получить все элементы с данным атрибутом name.
Например, все элементы с именем age:*/
var elems = document.getElementsByName('age');
/*До появления стандарта HTML5 этот метод возвращал только те элементы, 
в которых предусмотрена поддержка атрибута name, в частности: iframe, a, input и другими. 
В современных браузерах (IE10+) тег не имеет значения.
Используется этот метод весьма редко.*/


/*getElementsByClassName
Вызов elem.getElementsByClassName(className) возвращает коллекцию элементов
с классом className. Находит элемент и в том случае, если у него несколько классов,
а искомый – один из них.
Поддерживается всеми современными браузерами, кроме IE8-.
Как и getElementsByTagName, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.*/


/*querySelectorAll
Вызов elem.querySelectorAll(css) возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.
Это один из самых часто используемых и полезных методов при работе с DOM.
Он есть во всех современных браузерах, включая IE8+ (в режиме соответствия стандарту).*/

/*Псевдо-класс тоже работает
Псевдо-классы в CSS-селекторе, в частности :hover и :active, также поддерживаются. 
Например, document.querySelectorAll(':hover') вернёт список, 
в порядке вложенности, из текущих элементов под курсором мыши.*/


/*querySelector
Вызов elem.querySelector(css) возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
Иначе говоря, результат – такой же, как и при elem.querySelectorAll(css)[0], 
но в последнем вызове сначала ищутся все элементы, а потом берётся первый, 
а в elem.querySelector(css) ищется только первый, то есть он эффективнее.
Этот метод часто используется, когда мы заведомо знаем, что подходящий 
элемент только один, и хотим получить в переменную сразу его.*/


/*matches
Предыдущие методы искали по DOM.
Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. 
Он возвращает true либо false. Не поддерживается в IE8-.
Этот метод бывает полезным, когда мы перебираем элементы (в массиве или по обычным
навигационным ссылкам) и пытаемся отфильтровать те из них, которые нам интересны.
Ранее в спецификации он назывался matchesSelector, и большинство браузеров поддерживают
его под этим старым именем, либо с префиксами ms/moz/webkit.*/


/*closest
Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css.
Сам элемент тоже включается в поиск.
Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет,
подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его.
Он самый новый из методов, рассмотренных в этой главе, поэтому старые браузеры его слабо поддерживают. Это, конечно, легко поправимо, как мы увидим позже в главе Современный DOM: полифиллы.*/


/*XPath в современных браузерах
Для полноты картины рассмотрим ещё один способ поиска,
который обычно используется в XML. Это язык запросов XPath.
Он очень мощный, во многом мощнее CSS, но сложнее. 
Например, запрос для поиска элементов H2, содержащих текст "XPath", 
будет выглядеть так: //h2[contains(., "XPath")].
IE тоже поддерживает XPath, но эта поддержка не соответствует стандарту и 
работает только для XML-документов, например, полученных с помощью XMLHTTPRequest (AJAX). 
Для обычных же HTML-документов XPath в IE не поддерживается.

Так как XPath сложнее и длиннее CSS, то используют его очень редко.*/




