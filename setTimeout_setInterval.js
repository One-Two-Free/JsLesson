/*Почти все реализации JavaScript имеют внутренний таймер-планировщик, 
который позволяет задавать вызов функции через заданный период времени.
В частности, эта возможность поддерживается в браузерах и в сервере Node.JS.*/

/*setTimeout
Синтаксис:
var timerId = setTimeout(func / code, delay[, arg1, arg2...])
Параметры:
func/code  Функция или строка кода для исполнения. 
Строка поддерживается для совместимости, использовать её не рекомендуется.
delay Задержка в миллисекундах, 1000 миллисекунд равны 1 секунде.
arg1, arg2…  Аргументы, которые нужно передать функции. Не поддерживаются в IE9-.

Исполнение функции произойдёт спустя время, указанное в параметре delay.
Например, следующий код вызовет func() через одну секунду:*/
function func() {alert( 'Привет' );}
setTimeout(func, 1000);

//С передачей аргументов (не сработает в IE9-):
function func(phrase, who) {alert( phrase + ', ' + who );}
setTimeout(func, 1000, "Привет", "Вася"); // Привет, Вася


/*Если первый аргумент является строкой, то интерпретатор создаёт анонимную функцию из этой строки.
То есть такая запись тоже сработает:*/
 setTimeout("alert('Привет')", 1000);
/*Однако, использование строк не рекомендуется, так как они могут вызвать 
проблемы при минимизации кода, и, вообще, сама возможность использовать 
строку сохраняется лишь для совместимости.
Вместо них используйте анонимные функции, вот так:*/
setTimeout(function() { alert('Привет') }, 1000);


/*Отмена исполнения clearTimeout
Функция setTimeout возвращает числовой идентификатор таймера timerId, 
который можно использовать для отмены действия.
Синтаксис:*/
var timerId = setTimeout(...);
clearTimeout(timerId);

/*в браузере идентификатор таймера является обычным числом. 
Другие JavaScript-окружения, например Node.JS, могут возвращать объект таймера, с дополнительными методами.
Такие разночтения вполне соответствуют стандарту просто потому, 
что в спецификации JavaScript про таймеры нет ни слова.
Таймеры – это надстройка над JavaScript, которая описана в секции Timers 
стандарта HTML5 для браузеров и в документации к Node.JS – для сервера.*/


/*setInterval
Метод setInterval имеет синтаксис, аналогичный setTimeout.
var timerId = setInterval(func / code, delay[, arg1, arg2...])
Смысл аргументов – тот же самый. Но, в отличие от setTimeout, он запускает выполнение функции не один раз, а регулярно повторяет её через указанный интервал времени. Остановить исполнение можно вызовом clearInterval(timerId).
Следующий пример при запуске станет выводить сообщение каждые две секунды, пока не пройдёт 5 секунд:*/
// начать повторы с интервалом 2 сек
var timerId = setInterval(function() {alert( "тик" );}, 2000);
// через 5 сек остановить повторы
setTimeout(function() {clearInterval(timerId);alert( 'стоп' );}, 5000);

/*Модальные окна замораживают время в Chrome/Opera/Safari
Что будет, если долго не жать OK на появившемся alert? Это зависит от браузера.
В браузерах Chrome, Opera и Safari внутренний таймер «заморожен» во время показа alert/confirm/prompt. 
А вот в IE и Firefox внутренний таймер продолжит идти.
Поэтому, если закрыть alert после небольшой паузы, то в Firefox/IE следующий alert будет 
показан сразу же (время подошло), а в Chrome/Opera/Safari – только через 2 секунды после закрытия.*/



/*Рекурсивный setTimeout
Важная альтернатива setInterval – рекурсивный setTimeout:*/
/* вместо: 
var timerId = setInterval(function() {alert( "тик" );}, 2000);*/

var timerId = setTimeout(function tick() {
  alert( "тик" );
  timerId = setTimeout(tick, 2000);
}, 2000);


/*Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval, 
так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего.
Например, у нас есть сервис, который раз в 5 секунд опрашивает сервер на предмет 
новых данных. В случае, если сервер перегружен, можно увеличивать интервал
опроса до 10, 20, 60 секунд… А потом вернуть обратно, когда всё нормализуется.
Если у нас регулярно проходят грузящие процессор задачи, то мы можем оценивать время, 
потраченное на их выполнение, и планировать следующий запуск раньше или позже.
Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.*/

/*Реальная пауза между вызовами func при setInterval меньше, чем указана в коде!
Это естественно, ведь время работы функции никак не учитывается, оно «съедает» часть интервала.
Возможно и такое что func оказалась сложнее, чем мы рассчитывали и выполнялась дольше, чем 100 мс.
В этом случае интерпретатор будет ждать, пока функция завершится, затем проверит таймер и, если время вызова setInterval уже подошло (или прошло), то следующий вызов произойдёт сразу же.
Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.
Исключением является IE, в котором таймер «застывает» во время выполнения JavaScript.*/

/*При рекурсивном setTimeout задержка всегда фиксирована и равна 100 мс.
Это происходит потому, что каждый новый запуск планируется только после окончания текущего.*/


/*Управление памятью
Сборщик мусора в JavaScript не чистит функции, назначенные в таймерах, пока таймеры актуальны.
При передаче функции в setInterval/setTimeout создаётся внутренняя ссылка на неё, через которую браузер её будет запускать, и которая препятствует удалению из памяти, даже если функция анонимна.
// Функция будет жить в памяти, пока не сработал (или не был очищен) таймер
setTimeout(function() {}, 100);
Для setTimeout – внутренняя ссылка исчезнет после исполнения функции.
Для setInterval – ссылка исчезнет при очистке таймера.
Так как функция также тянет за собой всё замыкание, то ставшие неактуальными, но не отменённые setInterval могут приводить к излишним тратам памяти.*/

/*Важно:
В Internet Explorer, нулевая задержка setInterval(.., 0) не сработает. Это касается именно setInterval, т.е. setTimeout(.., 0) работает нормально.*/

/*Итого
Методы setInterval(func, delay) и setTimeout(func, delay) позволяют запускать func регулярно/один раз через delay миллисекунд.
Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом clearInterval/clearTimeout.
В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо setInterval используют рекурсивный setTimeout.
Минимальная задержка по стандарту составляет 4 мс. Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки.
В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.*/












