/*Генерация событий на элементах

Конструктор Event
Объект события в нём создаётся при помощи встроенного конструктора Event. Синтаксис:
var event = new Event(тип события[, флаги]);
	Тип события – может быть как своим, так и встроенным, к примеру "click".
	Флаги – объект вида { bubbles: true/false, cancelable: true/false }, где свойство bubbles указывает,
	всплывает ли событие, а cancelable – можно ли отменить действие по умолчанию.
Флаги по умолчанию: {bubbles: false, cancelable: false}.*/

/*Метод dispatchEvent
Затем, чтобы инициировать событие, запускается elem.dispatchEvent(event).
При этом событие срабатывает наравне с браузерными, то есть обычные браузерные
обработчики на него отреагируют. Если при создании указан флаг bubbles, то оно будет всплывать.*/


/*Отмена действия по умолчанию
На сгенерированном событии, как и на встроенном браузерном, обработчик может вызвать метод event.preventDefault(). Тогда dispatchEvent возвратит false.
Остановимся здесь подробнее. Обычно вызов preventDefault() предотвращает действие браузера. В случае, если событие придумано нами, имеет нестандартное имя – никакого действия браузера, конечно, нет.
Но код, который генерирует событие, может предусматривать какие-то ещё действия после dispatchEvent.
Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия продолжать не надо.*/

/*Как отличить реальное нажатие от скриптового?
В целях безопасности иногда хорошо бы знать – инициировано ли действие посетителем или это кликнул скрипт.
Единственный способ, которым код может отличить реальное нажатие от программного, является проверка свойства event.isTrusted.
Оно на момент написания статьи поддерживается IE и Firefox и равно true, если посетитель кликнул сам, и всегда false – если событие инициировал скрипт.*/


/*Другие свойства событий
При создании события браузер автоматически ставит следующие свойства:

	isTrusted: false – означает, что событие сгенерировано скриптом, это свойство изменить невозможно.
	target: null – это свойство ставится автоматически позже при dispatchEvent.
	type: тип события – первый аргумент new Event.
	bubbles, cancelable – по второму аргументу new Event.*/


/*Конструкторы MouseEvent, KeyboardEvent и другие
Для некоторых конкретных типов событий есть свои, специфические, конструкторы.
Вот список конструкторов для различных событий интерфейса которые можно найти в спецификации UI Event:
	UIEvent
	FocusEvent
	MouseEvent
	WheelEvent
	KeyboardEvent
	CompositionEvent
Вместо new Event("click") можно вызвать new MouseEvent("click").
Специфический конструктор позволяет указать стандартные свойства для данного типа события.
Например, clientX/clientY для события мыши:*/
var e = new MouseEvent("click", {
  bubbles: true,  cancelable: true,
  clientX: 100,  clientY: 100
});
alert( e.clientX ); // 100
//Это нельзя было бы сделать с обычным конструктором Event:
var e = new Event("click", {
  bubbles: true,  cancelable: true,  clientX: 100,  clientY: 100});
alert( e.clientX ); // undefined, свойство не присвоено!
/*Обычный конструктор Event не знает про «мышиные» свойства, поэтому их игнорирует.
Впрочем, использование конкретного конструктора не является обязательным, можно обойтись Event, а свойства записать в объект отдельно, после конструктора. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.*/


/*Свои события
Для генерации своих, нестандартных, событий, хоть и можно использовать конструктор Event, 
но существует и специфический конструктор CustomEvent.
Технически, он абсолютно идентичен Event, кроме небольшой детали: у второго аргумента-объекта 
есть дополнительное свойство detail, в котором можно указывать информацию для передачи в событие.*/
<h1 id="elem">Привет для Васи!</h1>
<script>
  elem.addEventListener("hello", function(event) {
    alert( event.detail.name );}, false);

  var event = new CustomEvent("hello", { detail: { name: "Вася" } });
  elem.dispatchEvent(event);
</script>

/*Надо сказать, что никто не мешает и в обычное Event записать любые свойства. Но CustomEvent более явно говорит, что событие не встроенное, а своё, и выделяет отдельно «информационное» поле detail, в которое можно записать что угодно без конфликта со стандартными свойствами объекта.*/


/*Итого
	Все браузеры, кроме IE9-11, позволяют генерировать любые события, следуя стандарту DOM4.
	В IE9+ поддерживается более старый стандарт, можно легко сделать полифилл, например для CustomEvent он рассмотрен в этой главе.
	IE8- может генерировать только встроенные события.

Несмотря на техническую возможность генерировать встроенные браузерные события типа click или keydown – пользоваться ей стоит с большой осторожностью.
В 98% случаев, когда разработчик начинающего или среднего уровня хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода, и взаимодействие нужно на уровне выше.

Как правило события имеет смысл генерировать
	Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
	Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.
	Либо при создании своих «элементов интерфейса». Например, никто не мешает при помощи JavaScript создать из <div class="calendar"> красивый календарь и генерировать на нём событие change при выборе даты. Эту тему мы разовьём позже.*/









































