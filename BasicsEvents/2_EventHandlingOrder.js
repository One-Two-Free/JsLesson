/*Порядок обработки событий

Главный поток
В каждом окне выполняется только один главный поток, который занимается выполнением JavaScript, 
отрисовкой и работой с DOM.
Он выполняет команды последовательно, может делать только одно дело одновременно и 
блокируется при выводе модальных окон, таких как alert.*/

/*Дополнительные потоки тоже есть
Есть и другие, служебные потоки, например, для сетевых коммуникаций.
Поэтому скачивание файлов может продолжаться пока главный поток ждёт реакции на alert.
Но управлять служебными потоками мы не можем.

Web Workers
Существует спецификация Web Workers, которая позволяет запускать дополнительные JavaScript-процессы(workers).
Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе. Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.*/

/*Очередь событий

Произошло одновременно несколько событий или во время работы одного 
случилось другое – как главному потоку обработать это?
Если главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции
и прыгнуть в другую. А потом третью. Отладка при этом могла бы превратиться в кошмар,
потому что пришлось бы разбираться с совместным состоянием нескольких функций сразу.
Поэтому используется альтернативный подход.

Когда происходит событие, оно попадает в очередь.
Внутри браузера непрерывно работает «главный внутренний цикл», который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.
Иногда события добавляются в очередь сразу пачкой.
Например, при клике на элементе генерируется несколько событий:
	Сначала mousedown – нажата кнопка мыши.
	Затем mouseup – кнопка мыши отпущена и, так как это было над одним элементом, то дополнительно генерируется click (два события сразу).*/

/*Вложенные (синхронные) события
Обычно возникающие события «становятся в очередь».
Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.*/


/*Итого
JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы Web Workers,
они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.
Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.
Синхронными являются вложенные события, инициированные из кода.
Чтобы сделать событие гарантированно асинхронным, используется вызов через setTimeout(func, 0).
Отложенный вызов через setTimeout(func, 0) используется не только в событиях, а вообще – всегда,
когда мы хотим, чтобы некая функция func сработала после того, как текущий скрипт завершится.*/










































