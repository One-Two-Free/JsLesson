/*Всплытие и перехват

Всплытие
Основной принцип всплытия:
При наступлении события обработчики сначала срабатывают на самом вложенном элементе, 
затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.
Процесс называется всплытием, потому что события «всплывают» от внутреннего элемента вверх
через родителей, подобно тому, как всплывает пузырек воздуха в воде.*/

/*Целевой элемент event.target
На каком бы элементе мы ни поймали событие, всегда можно узнать, где конкретно оно произошло.
Самый глубокий элемент, который вызывает событие, называется «целевым»
или «исходным» элементом и доступен как event.target.
Отличия от this (=event.currentTarget):
	event.target – это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.
	this – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. 
Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.

При этом:
	this (=event.currentTarget) всегда будет сама форма, так как обработчик сработал на ней.
	event.target будет содержать ссылку на конкретный элемент внутри формы,
	самый вложенный, на котором произошёл клик.
Возможна и ситуация, когда event.target и this – один и тот же элемент, например если в форме нет других тегов и клик был на самом элементе <form>.*/

/*Прекращение всплытия
Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <html>,
а затем до document, а иногда даже до window, вызывая все обработчики на своем пути.
Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
Для остановки всплытия нужно вызвать метод event.stopPropagation().*/

/*event.stopImmediatePropagation()
Если у элемента есть несколько обработчиков на одно событие, 
то даже при прекращении всплытия все они будут выполнены.

То есть, stopPropagation препятствует продвижению события дальше, 
но на текущем элементе все обработчики отработают.

Для того, чтобы полностью остановить обработку, современные браузеры поддерживают 
метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, 
но и останавливает обработку событий на текущем элементе.*/

/*Не прекращайте всплытие без необходимости!
Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.
Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.
Например:
Мы делаем меню. Оно обрабатывает клики на своих элементах и делает для них stopPropagation. Вроде бы, всё работает.
Позже мы решили отслеживать все клики в окне, для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Например, Яндекс.Метрика так делает, если включить соответствующую опцию.
Над областью, где клики убиваются stopPropagation, статистика работать не будет! Получилась «мёртвая зона».
Проблема в том, что stopPropagation убивает всякую возможность отследить событие сверху, а это бывает нужно для реализации чего-нибудь «эдакого», что к меню отношения совсем не имеет.*/

/*Погружение
В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
Строго говоря, стандарт выделяет целых три стадии прохода события:
	1 Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
	2 Событие достигло целевого элемента. Это – «стадия цели» (target stage).
	3 После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).

То есть, при клике на TD событие путешествует по цепочке родителей сначала вниз к элементу («погружается»), а потом наверх («всплывает»), по пути задействуя обработчики.
Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.

Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
	Если аргумент true, то событие будет перехвачено по дороге вниз.
	Если аргумент false, то событие будет поймано при всплытии.*
Стадия цели, обозначенная на рисунке цифрой (2), особо не обрабатывается, так как обработчики,
назначаемые обоими этими способами, срабатывают также на целевом элементе./

/*Итого
Алгоритм:
	-При наступлении события – элемент, на котором оно произошло, помечается как «целевой» (event.target).
	-Далее событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, 	поставленные через addEventListener(...., true).
	-Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on* и addEventListener(...., false).
	
Каждый обработчик имеет доступ к свойствам события:
	event.target – самый глубокий элемент, на котором произошло событие.
	event.currentTarget (=this) – элемент, на котором в данный момент
	сработал обработчик (до которого «доплыло» событие).
	event.eventPhase – на какой фазе он сработал (погружение =1, всплытие = 3).

Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, 
так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
В современной разработке стадия погружения используется очень редко.
Этому есть две причины:
	1 Историческая – так как IE лишь с версии 9 в полной мере поддерживает современный стандарт.

	2 Разумная – когда происходит событие, то разумно дать возможность первому сработать обработчику на самом элементе, поскольку он наиболее конкретен. Код, который поставил обработчик именно на этот элемент, знает максимум деталей о том, что это за элемент, чем он занимается.
	Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document, обработчик на котором реализовывает самую общую функциональность уровня документа.*/






































