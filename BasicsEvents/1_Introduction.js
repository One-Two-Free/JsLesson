/*Введение в браузерные события
Событие – это сигнал от браузера о том, что что-то произошло. Существует много видов событий.

События мыши:
	click – происходит, когда кликнули на элемент левой кнопкой мыши
	contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши
	mouseover – возникает, когда на элемент наводится мышь
	mousedown и mouseup – когда кнопку мыши нажали или отжали
	mousemove – при движении мыши

События на элементах управления:
	submit – посетитель отправил форму <form>
	focus – посетитель фокусируется на элементе, например нажимает на <input>

Клавиатурные события:
	keydown – когда посетитель нажимает клавишу
	keyup – когда посетитель отпускает клавишу
	
События документа:
	DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

События CSS:
	transitionend – когда CSS-анимация завершена.*/


	/*Назначение обработчиков событий
Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
Именно благодаря обработчикам JavaScript-код может реагировать на действия посетителя.

Использование атрибута HTML
Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.
Например, чтобы прикрепить click-событие к input кнопке, можно присвоить обработчик onclick, вот так:
<input value="Нажми меня" onclick="alert('Клик!')" type="button">
Обратите внимание, для содержимого атрибута onclick используются одинарные кавычки, 
так как сам атрибут находится в двойных.*/


/*Использование свойства DOM-объекта
Можно назначать обработчик, используя свойство DOM-элемента on<событие>.
Пример установки обработчика click:*/
<input id="elem" type="button" value="Нажми меня" />
<script>
  elem.onclick = function() {
    alert( 'Спасибо' );
  };
</script>
/*Если обработчик задан через атрибут, то браузер читает HTML-разметку, 
создаёт новую функцию из содержимого атрибута и записывает в свойство onclick.
Этот способ, по сути, аналогичен предыдущему.
Обработчик хранится именно в DOM-свойстве, а атрибут – лишь один из способов его инициализации.
Так как DOM-свойство onclick, в итоге, одно, то назначить более одного обработчика так нельзя.
обработчиком можно назначить и уже существующую функцию
Если обработчик надоел – его всегда можно убрать назначением elem.onclick = null.*/


/*Доступ к элементу через this
Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал.
Это можно использовать, чтобы получить свойства или изменить элемент.
В коде ниже button выводит свое содержимое, используя this.innerHTML:
<button onclick="alert(this.innerHTML)">Нажми меня</button>*/


/*Частые ошибки
Если вы только начинаете работать с событиями – обратите внимание на следующие особенности.
Функция должна быть присвоена как sayThanks, а не sayThanks().
button.onclick = sayThanks;
Если добавить скобки, то sayThanks() – будет уже результат выполнения функции (а так как в ней нет return, то в onclick попадёт undefined). Нам же нужна именно функция.
…А вот в разметке как раз скобки нужны:*/
<input type="button" id="button" onclick="sayThanks()" />
/*Используйте именно функции, а не строки.
Назначение обработчика строкой elem.onclick = "alert(1)" можно иногда увидеть в древнем коде. Это будет работать, но не рекомендуется, могут быть проблемы при сжатии JavaScript. Да и вообще, передавать код в виде строки по меньшей мере странно в языке, который поддерживает Function Expressions. Это возможно лишь по соображениям совместимости, не делайте так.

Не используйте setAttribute.
Такой вызов работать не будет:*/
// при нажатии на body будут ошибки
// потому что при назначении в атрибут функция будет преобразована в строку
document.body.setAttribute('onclick', function() { alert(1) });

/*addEventListener и removeEventListener
Методы addEventListener и removeEventListener являются современным способом назначить
или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.
Назначение обработчика осуществляется вызовом addEventListener с тремя аргументами:*/
element.addEventListener(event, handler[, phase]);
/*event		Имя события, например click
handler		Ссылка на функцию, которую надо поставить обработчиком.
phase		Необязательный аргумент, «фаза», на которой обработчик должен сработать.
Удаление обработчика осуществляется вызовом removeEventListener:*/
// передать те же аргументы, что были у addEventListener
element.removeEventListener(event, handler[, phase]);


/*Удаление требует именно ту же функцию
Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
Вот так removeEventListener не сработает:
elem.addEventListener( "click" , function() {alert('Спасибо!')});
// ....
elem.removeEventListener( "click", function() {alert('Спасибо!')});

В removeEventListener передана не та же функция, а другая, с одинаковым кодом, но это не важно.
Вот так правильно:
function handler() {
  alert( 'Спасибо!' );
}
input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
Обратим внимание – если функцию не сохранить где-либо, а просто передать в addEventListener,
как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно.
Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener.*/

/*Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента, например:*/
<input id="elem" type="button" value="Нажми меня"/>
<script>
  function handler1() {    alert('Спасибо!');  };

  function handler2() {    alert('Спасибо ещё раз!');  }
  elem.onclick = function() { alert("Привет"); };
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>
/*Как видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство
и через addEventListener. Однако, во избежание путаницы, рекомендуется выбрать один способ.*/

/*addEventListener работает всегда, а DOM-свойство – нет
У специальных методов есть ещё одно преимущество перед DOM-свойствами.
Есть некоторые события, которые нельзя назначить через DOM-свойство, но можно через addEventListener.
Например, таково событие transitionend, то есть окончание CSS-анимации. 
В большинстве браузеров оно требует назначения через addEventListener.*/


/*Отличия IE8-
При работе с событиями в IE8- есть много отличий. Как правило, они формальны – некое свойство или метод называются по-другому. Начиная с версии 9, также работают и стандартные свойства и методы.
В IE8- вместо addEventListener/removeEventListener используются свои методы.
У обработчиков, назначенных с attachEvent, нет this
Обработчики, назначенные с attachEvent не получают this!
Это важная особенность и подводный камень старых IE.
Чтобы ваш код работал в старом IE, нужно либо использовать DOM-свойства,
то есть onclick, либо подключить полифилл для современных методов, например такой или с сервиса polyfill.io или какой-то другой.*/

/*Итого
Есть три способа назначения обработчиков событий:
	Атрибут HTML: onclick="...".
	Свойство: elem.onclick = function.
	Специальные методы:
		Современные: elem.addEventListener( событие, handler[, phase]), удаление через removeEventListener.
Для старых IE8-: elem.attachEvent( on+событие, handler ), удаление через detachEvent.*/























